//+------------------------------------------------------------------+
//| This MQL is generated by Expert Advisor Builder                  |
//|                http://sufx.core.t3-ism.net/ExpertAdvisorBuilder/ |
//|                                                                  |
//|  In no event will author be liable for any damages whatsoever.   |
//|                      Use at your own risk.                       |
//|                                                                  |
//|   Modified by Lucas Liew                                         |                                                                 
//|                                                                  |
//+------------------- DO NOT REMOVE THIS HEADER --------------------+
   
   /* 
   -----
   
   Hey guys,
   
   I strongly encourage you stay in touch with our course updates 
   & new course launches (on Machine Learning, Data Science etc) by joining our mailing list.
   This allows me to have a channel to keep in touch with you. 
   No spam, and you can unsubscribe anytime. =)
   
   Link: http://eepurl.com/bVQiXr
   
   After you sign up, we will send you our Ebook - "Black Algo Strategy Development Guide".
   We are looking to create more ebooks/guides for you guys. Will send them to you via email once they
   are out!
   
   Cheers,
   Lucas
   
   -----
   */
   
   /* 
      ADELINE ENTRY RULES:
      Enter a long trade when SMA(10) crosses SMA(40) from bottom
      Enter a short trade when SMA(10) crosses SMA(40) from top
   
      ADELINE EXIT RULES:
      Exit the long trade when SMA(10) crosses SMA(40) from top
      Exit the short trade when SMA(10) crosses SMA(40) from bottom
      30 pips hard stop (30pips from initial entry price)
      Trailing stop of 30 pips
   
      ADELINE POSITION SIZING RULE:
      1 Lot
   */

#define SIGNAL_NONE 0
#define SIGNAL_BUY   1
#define SIGNAL_SELL  2
#define SIGNAL_CLOSEBUY 3
#define SIGNAL_CLOSESELL 4

#property copyright "Expert Advisor Builder"
#property link      "http://sufx.core.t3-ism.net/ExpertAdvisorBuilder/"

// TDL 5: Stops and Position Sizing

extern int MagicNumber = 12345;
extern bool SignalMail = False;
extern double Lots = 0.1;
extern int Slippage = 3;
extern bool UseStopLoss = True;
extern int StopLoss = 1;
extern bool UseTakeProfit = False;
extern int TakeProfit = 0;
extern bool UseTrailingStop = True;
extern int TrailingStop = 1;
extern int TrailingStopCandle = 2;
extern double ema_ratio = 0.5;
extern double candle_ratio = 1.9;

int P = 1;
int Order = SIGNAL_NONE;
int Total, Ticket, Ticket2, Ticket3;
double StopLossLevel, TakeProfitLevel, StopLevel, Spread, ticksize;
bool buy = False; 
bool sell = False;

// To-Do-List (TDL) 1: Declare Variables 
double ema_1, ema_2, candle_1, candle_2;

int LastOrderClosedMinAgo() {
   if (OrdersHistoryTotal() > 0){
      Ticket3 = OrdersHistoryTotal()-1; 
      if (OrderSelect(Ticket3, SELECT_BY_POS, MODE_HISTORY)){ 
         return((TimeCurrent() - OrderCloseTime())/60);
         }
      else{ 
         Print("LastOrderClosedMinAgo(): OrderSelect error code = ",GetLastError(),", Ticket 3 = ",Ticket3);
         return 0;
         }
   }
   else   
      return Period();
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int init() {
   
   if(Digits == 5 || Digits == 3 || Digits == 1)P = 10;
   else P = 1; // To account for 5 digit brokers

   return(0);
}
//+------------------------------------------------------------------+
//| Expert initialization function - END                             |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
int deinit() {
   return(0);
}
//+------------------------------------------------------------------+
//| Expert deinitialization function - END                           |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Expert start function                                            |
//+------------------------------------------------------------------+
int start() {

   Total = OrdersTotal();
   Order = SIGNAL_NONE;

   //+------------------------------------------------------------------+
   //| Variable Setup                                                   |
   //+------------------------------------------------------------------+
 
   // TDL 2: Assign Values to variables

   ema_1 = iMA(NULL, 0, 21, 0, MODE_EMA, PRICE_CLOSE, 1); // c
   ema_2 = iMA(NULL, 0, 21, 0, MODE_EMA, PRICE_CLOSE, 2); // b
   candle_1 = MathAbs(Open[1]-Close[1]);
   candle_2 = MathAbs(Open[2]-Close[2]);

   StopLevel = (MarketInfo(Symbol(), MODE_STOPLEVEL) / P); // Defining minimum StopLevel (MarketInfo(Symbol(), MODE_STOPLEVEL) + MarketInfo(Symbol(), MODE_SPREAD)) / P;
   Spread = MarketInfo(Symbol(), MODE_SPREAD); 
   ticksize = MarketInfo(Symbol(), MODE_TICKSIZE);
  
   //Print(buy, sell);
   Print(Digits, "--, ", 
      DoubleToString(Open[1], Digits), ", ", 
      DoubleToString(Close[1], Digits), ", ", 
      MarketInfo(Symbol(), MODE_STOPLEVEL), ", ", 
      DoubleToString(ema_1, Digits), ", ", 
      DoubleToString(candle_1, Digits), ", ", 
      ema_ratio/10, ", ", 
      DoubleToString(ema_ratio/10 * candle_1, Digits), ", ", 
      DoubleToString(ema_1 + (ema_ratio/10 * candle_1), Digits), ", ", 
      DoubleToString(ema_1 - (ema_ratio/10 * candle_1), Digits)     
      );

   if (StopLoss < StopLevel) StopLoss = StopLevel;
   if (TakeProfit < StopLevel) TakeProfit = StopLevel;

   //+------------------------------------------------------------------+
   //| Variable Setup - END                                             |
   //+------------------------------------------------------------------+

   //Check position
   bool IsTrade = False;

   for (int i = 0; i < Total; i ++) {
      Ticket2 = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderType() <= OP_SELL &&  OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
         IsTrade = True;
         if(OrderType() == OP_BUY) {
            //Close

            //+------------------------------------------------------------------+
            //| Signal Begin(Exit Buy)                                           |
            //+------------------------------------------------------------------+

            /* ADELINE EXIT RULES:
               Exit the long trade when SMA(10) crosses SMA(40) from top
               Exit the short trade when SMA(10) crosses SMA(40) from bottom
               30 pips hard stop (30pips from initial entry price)
               Trailing stop of 30 pips
            */
            
            // TDL 4: Code Exit Rules
            
            if(
            Close[1] < Open[1]
            && Close[2] > ema_2 
            && Close[1] < ema_1    
            )
            Order = SIGNAL_CLOSEBUY; // Rule to EXIT a Long trade
            
            //+------------------------------------------------------------------+
            //| Signal End(Exit Buy)                                             |
            //+------------------------------------------------------------------+

            if (Order == SIGNAL_CLOSEBUY) {
               Print("Close BUY");
               Print(Close[2], ema_2, Close[1], ema_1);
               Ticket2 = OrderClose(OrderTicket(), OrderLots(), Bid, Slippage, MediumSeaGreen);
               if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Bid, Digits) + " Close Buy");
               IsTrade = False;
               continue;
            }
            //Trailing stop for buy
            if(UseTrailingStop && TrailingStop > 0) {                 
               if(buy == True) {
                  if(
                     (NormalizeDouble((Low[TrailingStopCandle] - (TrailingStop * P)*Point),Digits) > NormalizeDouble(OrderStopLoss(), Digits)) 
                     && (NormalizeDouble((Low[TrailingStopCandle] - (TrailingStop * P)*Point),Digits) <= NormalizeDouble((Ask-StopLevel*Point),Digits)) 
                  ) 
                  {
                     Ticket2 = OrderModify(OrderTicket(), OrderOpenPrice(), NormalizeDouble((Low[TrailingStopCandle] - (TrailingStop * P) * Point), Digits), OrderTakeProfit(), 0, MediumSeaGreen);
                     continue;
                  } else return 0;
               }
            }
         } else {
            //Close

            //+------------------------------------------------------------------+
            //| Signal Begin(Exit Sell)                                          |
            //+------------------------------------------------------------------+

            if (
            Close[1] > Open[1]
            && Close[2] < ema_2 
            && Close[1] > ema_1
            ) 
            Order = SIGNAL_CLOSESELL; // Rule to EXIT a Short trade
            
            //+------------------------------------------------------------------+
            //| Signal End(Exit Sell)                                            |
            //+------------------------------------------------------------------+

            if (Order == SIGNAL_CLOSESELL) {
               Print("Close SELL");
               Print(Close[2], ema_2, Close[1], ema_1);
               Ticket2 = OrderClose(OrderTicket(), OrderLots(), Ask, Slippage, DarkOrange);
               if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Ask, Digits) + " Close Sell");
               IsTrade = False;
               continue;
            }
            //Trailing stop for sell
            if(UseTrailingStop && TrailingStop > 0) {                 
               if(sell == True) {
                  if(
                  (NormalizeDouble((High[TrailingStopCandle] + (TrailingStop * P) * Point), Digits) < NormalizeDouble(OrderStopLoss(), Digits)) 
                  && (NormalizeDouble((High[TrailingStopCandle] + (TrailingStop * P) * Point), Digits) >= NormalizeDouble((Bid+StopLevel*Point), Digits))  
                  ) {
                     Ticket2 = OrderModify(OrderTicket(), OrderOpenPrice(), NormalizeDouble((High[TrailingStopCandle] + (TrailingStop * P) * Point), Digits), OrderTakeProfit(), 0, DarkOrange);
                     continue;
                  } else return 0;
               }
            }
         }
      }
   }

   //+------------------------------------------------------------------+
   //| Signal Begin(Entries)                                            |
   //+------------------------------------------------------------------+

   /* ADELINE ENTRY RULES:
      Enter a long trade when SMA(10) crosses SMA(40) from bottom
      Enter a short trade when SMA(10) crosses SMA(40) from top
   */

   // TDL 3: Code Entry Rules
   
   if (    
      LastOrderClosedMinAgo() >= Period()
      && ema_1 > ema_2
      && Close[2] < Open[2]
      && Close[2] < ema_2
      && Close[1] > Open[1]
      && candle_1 >= candle_ratio * candle_2 
      && Close[1] >= ema_1 + (ema_ratio/10 * candle_1)
      ) 
      {
      Order = SIGNAL_BUY; // Rule to ENTER a Long trade
      buy = True;
      sell = False;
      }
  
   if (
      LastOrderClosedMinAgo() >= Period()
      && ema_1 < ema_2
      && Close[2] > Open[2]
      && Close[2] > ema_2 
      && Close[1] < Open[1]
      && candle_1 >= candle_ratio * candle_2 
      && Close[1] <= ema_1 - (ema_ratio/10 * candle_1)
      )
      {Order = SIGNAL_SELL; // Rule to ENTER a Short trade
      buy = False;
      sell = True;
      }


   //+------------------------------------------------------------------+
   //| Signal End                                                       |
   //+------------------------------------------------------------------+

   //Buy
   if (Order == SIGNAL_BUY) {
      Print("Open BUY");
      if(!IsTrade) {
         //Check free margin
         if (AccountFreeMargin() < (1000 * Lots)) {
            Print("We have no money. Free Margin = ", AccountFreeMargin());
            return(0);
         }

         if (UseStopLoss) 
            StopLossLevel = Low[1] - (StopLoss * P) * Point;
         else StopLossLevel = 0.0;
                  
         if (UseTakeProfit) 
            TakeProfitLevel = Ask + ((Close[1] - StopLossLevel) * TakeProfit);//* P * Point; //Close[1]
         else TakeProfitLevel = 0.0;

         Ticket = OrderSend(Symbol(), OP_BUY, Lots, Ask, Slippage, StopLossLevel, TakeProfitLevel, "Buy(#" + MagicNumber + ")", MagicNumber, 0, DodgerBlue);
         if(Ticket > 0) {
            if (OrderSelect(Ticket, SELECT_BY_TICKET, MODE_TRADES)) {
				Print("BUY order opened : ", OrderOpenPrice());
                if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Ask, Digits) + " Open Buy");
			} else {
				Print("Error opening BUY order : ", GetLastError());
			}
         }
         return(0);
      }
   }

   //Sell
   if (Order == SIGNAL_SELL) {
      Print("Open SELL");
      if(!IsTrade) {
         //Check free margin
         if (AccountFreeMargin() < (1000 * Lots)) {
            Print("We have no money. Free Margin = ", AccountFreeMargin());
            return(0);
         }

         if (UseStopLoss) 
            StopLossLevel = High[1] + (Spread + StopLoss * P) * Point;
         else StopLossLevel = 0.0;
                
         if (UseTakeProfit) 
            TakeProfitLevel = Bid - ((StopLossLevel - Close[1]) * TakeProfit);//* P * Point; //Close[1]
         else TakeProfitLevel = 0.0;

         Ticket = OrderSend(Symbol(), OP_SELL, Lots, Bid, Slippage, StopLossLevel, TakeProfitLevel, "Sell(#" + MagicNumber + ")", MagicNumber, 0, DeepPink);
         if(Ticket > 0) {
            if (OrderSelect(Ticket, SELECT_BY_TICKET, MODE_TRADES)) {
				Print("SELL order opened : ", OrderOpenPrice());
                if (SignalMail) SendMail("[Signal Alert]", "[" + Symbol() + "] " + DoubleToStr(Bid, Digits) + " Open Sell");
			} else {
				Print("Error opening SELL order : ", GetLastError());
			}
         }
         return(0);
      }
   }

   return(0);
}
//+------------------------------------------------------------------+
